[tox]
skip_missing_interpreters = true
requires = tox >= 3.20.0

[testenv]
basepython = {spell,clean,report,codecov,graphs,quickstart,apidoc,deploy}: {env:TOXPYTHON:python3}
passenv =
    *
    # See https://github.com/codecov/codecov-python/blob/5b9d539a6a09bc84501b381b563956295478651a/README.md#using-tox
    codecov: TOXENV
    codecov: CI
    codecov: TRAVIS TRAVIS_*
setenv =
    PYTHONPATH={toxinidir}/tests
    PYTHOUNBUFFERED=yes
    PIP_DISABLE_PIP_VERSION_CHECK=1
    VIRTUALENV_NO_DOWNLOAD=0
    DOCS_BUILD_LOCATION=dist/docs
deps =
    setuptools >= 40.0.0
    -rrequirements/docs.txt
skip_install = true


############## DOCUMENTATION OPERATIONS ##############
[testenv:quickstart]
description = Initialize the sphinx-docs infrastructure. You can run this 
    command once, after you just created a new project/code-repo.
changedir = docs
commands = sphinx-quickstart


[testenv:apidoc]
description = Populate rst files with directives to process docstrings. To force re-creation of
    files that already exist, you can use the -f flag; eg command: tox -c tox-dev.ini -e apidocs -- -f. To override the
    default filename 'modules', of the table of contents, you can use the --tocfile flag (takes 1 argument); eg command:
    tox -c tox-dev.ini -e apidoc -v -- --tocfile my_contents_filename
commands = sphinx-apidoc -o docs src/so_magic {posargs}



#### TESTING DOCS ####
[testenv:spell]
description = Check the documentation spelling. Checks spelling both for the .rst files in 'docs' directory and for the
    code docstrings. Writes the errors in separate .spelling files, in the {env:DOCS_BUILD_LOCATION:dist/docs}
    directory. Requires as external dependency the "pyenchant C library", which you should install manually (eg
    command on Linux: sudo apt install python-pyenchant).
setenv =
    {[testenv]setenv}
    SPELLCHECK=1
deps =
    {[testenv]deps}
    pyenchant
commands = sphinx-build -E -b spelling docs {env:DOCS_BUILD_LOCATION:dist/docs}


############## DEPLOY ##############

# usage 1
# deploy to testpypi while ignoring collisions (case where the version already exists on remote)
# python -m tox -c tox-dev.ini -e deploy

# usage 2
# deploy to pypi
# PYPI_SERVER=pypi python -m tox -c tox-dev.ini -e deploy

[testenv:deploy]
description = Deploy the python package to be hosted in a pypi server. Requires the SO_MAGIC_RELEASE_VERSION
    environment variable to contain the string that represents the semantic version (eg 0.5.3 or 1.0.0) under which
    to release the so_magic package to pypi. By default, deploys to the official test-pypi server.
    If you want to deploy to the "production" pypi then you have to set the PYPI_SERVER environment
    variable like `export PYPI_SERVER=pypi`. Also runs certain checks on the packaged distribution (.tar.gz and .whl)
deps =
    docutils
    readme-renderer
    pygments
    check-manifest
    pyroma
    keyring==21.3.0
    twine==3.4.0
skip_install = True
commands =
    check-manifest
    pyroma -d {toxinidir}
    python setup.py sdist bdist_wheel
    python -m twine check dist/so[\-_]magic-{env:SO_MAGIC_RELEASE_VERSION:PLEASE_INDICATE_THE_SEM_VER_FOR_RELEASE}*
    python -m twine {posargs:upload --non-interactive} --repository {env:PYPI_SERVER:testpypi --skip-existing} dist/so[\-_]magic-{env:SO_MAGIC_RELEASE_VERSION:PLEASE_INDICATE_THE_SEM_VER_FOR_RELEASE}* --verbose


###### COVERAGE ######
[testenv:clean]
description = Clean the working directory from any previously computed code coverage results.
deps = coverage
commands = coverage erase

[testenv:report]
description = Show the most recently computed codecoverage results.
deps = coverage
commands = {posargs:coverage report}

[testenv:format-report]
description = Generate xml and html formatted files out of previously computed code coverage results.
deps =
    coverage
    py<2.0.0
commands =
    coverage xml
    coverage html


###### CODECOV ######
[testenv:codecov]
description = Send code coverage data to codecov.io
passenv = TOXENV CI TRAVIS TRAVIS_* CODECOV_*
deps = codecov
commands = codecov


[testenv:prospector]
description = Analyse Python code and output information about errors, potential problems, convention violations and complexity.
    Runs the prospector tool which brings together the functionality of other Python analysis tools such as Pyflakes and McCabe complexity.
    We run tools: Pyflakes, Pyroma, McCabe and Dodgy
basepython = {env:TOXPYTHON:python3.6}
deps = prospector[with_pyroma]
commands =
    ; prospector --help
    prospector {posargs: -t pyflakes -t pyroma -t mccabe -t dodgy -s medium --max-line-length 120 -T -A}


[testenv:pyreverse]
description = Generate UML (class and package) diagrams by inspecting the code. The diagrams are stored in the
    $SO_MAGIC_UML_DIAGRAMS dir. Runs the pyreverse tool to parse the code and generate the files. This is a pretty legacy tool currently integrated in pylint (not available through pip).
basepython = {env:TOXPYTHON:python3.6}
setenv =
    {[testenv]setenv}
    # include dirs to pythonpath to solve issue of inspect lib failing with for some relative imports
    PYTHONPATH={toxinidir}/src/so_magic:{toxinidir}/src/so_magic/data
    SO_MAGIC_UML_DIAGRAMS=uml-diagrams
deps =
    attrs
    pandas
    numpy
    scikit-learn
    pylint==2.7.4
skip_install = false
use_develop = true
commands_pre =
    - python -c 'import os; my_dir = os.getcwd(); os.mkdir(os.path.join(my_dir, "{env:SO_MAGIC_UML_DIAGRAMS}"))'
commands =
    python -c 'import sys; print(sys.path)'
    # so_magic.utils
    pyreverse {posargs: -o png -A -p utils src/so_magic/utils}
    pyreverse {posargs: -o svg -A -p utils src/so_magic/utils}

    # so_magic.som
    pyreverse {posargs: -o png -A -p som src/so_magic/som}
    pyreverse {posargs: -o svg -A -p som src/so_magic/som}

    # so_magic.data.datapoints
    pyreverse {posargs: -o png -A -p data.datapoints src/so_magic/data/datapoints}
    pyreverse {posargs: -o svg -A -p data.datapoints src/so_magic/data/datapoints}
    # so_magic.data.features
    pyreverse {posargs: -o png -A -p data.features src/so_magic/data/features}
    pyreverse {posargs: -o svg -A -p data.features src/so_magic/data/features}
    # so_magic.data.backend
    pyreverse {posargs: -o png -A -p data.backend src/so_magic/data/backend}
    pyreverse {posargs: -o svg -A -p data.backend src/so_magic/data/backend}
    pyreverse {posargs: -o png -k -A -p data.backend-only-class-names src/so_magic/data/backend}
    pyreverse {posargs: -o svg -k -A -p data.backend-only-class-names src/so_magic/data/backend}
    # so_magic.data.variables
    pyreverse {posargs: -o png -A -p data.variables src/so_magic/data/variables}
    pyreverse {posargs: -o svg -A -p data.variables src/so_magic/data/variables}

    # so_magic.data
    pyreverse {posargs: -o png -A -p data src/so_magic/data}
    pyreverse {posargs: -o svg -A -p data src/so_magic/data}
    pyreverse {posargs: -o png -k -A -p data-only-class-names src/so_magic/data}
    pyreverse {posargs: -o svg -k -A -p data-only-class-names src/so_magic/data}

    # so_magic
    pyreverse {posargs: -o png -A -p so_magic src/so_magic}
    pyreverse {posargs: -o svg -A -p so_magic src/so_magic}
    pyreverse {posargs: -o png -k -A -p so_magic-only-class-names src/so_magic}
    pyreverse {posargs: -o svg -k -A -p so_magic-only-class-names src/so_magic}

    # so_magic.so_master
    pyreverse {posargs: -o png -A -p so_magic.so_master src/so_magic/so_master.py}
    pyreverse {posargs: -o svg -A -p so_magic.so_master src/so_magic/so_master.py}

    pyreverse {posargs: -o png -A -p data.data_manager src/so_magic/data/data_manager.py}
    pyreverse {posargs: -o svg -A -p data.data_manager src/so_magic/data/data_manager.py}
    pyreverse {posargs: -o png -A -p data.magic_datapoints_factory src/so_magic/data/magic_datapoints_factory.py}
    pyreverse {posargs: -o svg -A -p data.magic_datapoints_factory src/so_magic/data/magic_datapoints_factory.py}

    # MOVE uml diagram files manually into $SO_MAGIC_UML_DIAGRAMS directory (the pyreverse -p flag does not fully work when invoked with tox)
    python -c 'import shutil, glob; uml_diagrams = glob.glob("classes_*.png", recursive=False); print(uml_diagrams); exec("for file in uml_diagrams:\n    shutil.move(file, \"{env:SO_MAGIC_UML_DIAGRAMS}\")")'
    python -c 'import shutil, glob; uml_diagrams = glob.glob("classes_*.svg", recursive=False); print(uml_diagrams); exec("for file in uml_diagrams:\n    shutil.move(file, \"{env:SO_MAGIC_UML_DIAGRAMS}\")")'
    python -c 'import shutil, glob; uml_diagrams = glob.glob("packages_*.png", recursive=False); print(uml_diagrams); exec("for file in uml_diagrams:\n    shutil.move(file, \"{env:SO_MAGIC_UML_DIAGRAMS}\")")'
    python -c 'import shutil, glob; uml_diagrams = glob.glob("packages_*.svg", recursive=False); print(uml_diagrams); exec("for file in uml_diagrams:\n    shutil.move(file, \"{env:SO_MAGIC_UML_DIAGRAMS}\")")'

    # PRINT message
    python -c 'import os; my_dir = os.getcwd(); print("\nGenerated uml diagram(s), as svg/png files."); print("The diagram(s) reside in the \"" + os.path.join(my_dir, "{env:SO_MAGIC_UML_DIAGRAMS}") + "\" directory.\n")'
